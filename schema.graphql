scalar Upload
scalar DateTime
scalar JSON

schema {
  query: Query
  mutation: Mutation
}

"The query type, represents all of the entry points into our object graph"
type Query {
  hive(id: ID!): Hive
  apiary(id: ID!): Apiary
  hiveFrame(id: ID!): Frame
  hiveFrameSide(id: ID!): FrameSide
  apiaries: [Apiary]

  inspection(inspectionId: ID!): Inspection
  randomHiveName(language: String): String
  inspections(hiveId: ID!, limit: Int): [Inspection]


  hivePlacements(apiaryId: ID!): [HivePlacement]
  apiaryObstacles(apiaryId: ID!): [ApiaryObstacle]
}

"The mutation type, represents all updates we can make to our data"
type Mutation {
  addApiary(apiary: ApiaryInput!): Apiary
  updateApiary(id: ID!, apiary: ApiaryInput!): Apiary
	deactivateApiary(id: ID!): Boolean

  addHive(hive: HiveInput!): Hive
  updateHive(hive: HiveUpdateInput!): Hive
  deactivateHive(id: ID!): Boolean

  addBox(hiveId: ID!, position: Int!, color: String, type: BoxType!): Box!
  updateBoxColor(id: ID!, color: String): Boolean!
  deactivateBox(id: ID!): Boolean
  swapBoxPositions(id: ID!, id2: ID!): Boolean

  addFrame(boxId: ID!, type: String!, position: Int!): Frame!
  updateFrames(frames: [FrameInput]!) : [Frame]
  deactivateFrame(id: ID!): Boolean

  addInspection(inspection: InspectionInput!): Inspection

  addQueenToHive(hiveId: ID!, queen: FamilyInput!): Family
  removeQueenFromHive(hiveId: ID!, familyId: ID!): Boolean

  treatHive(treatment: TreatmentOfHiveInput!): Boolean
  treatBox(treatment: TreatmentOfBoxInput!): Boolean

  markHiveAsCollapsed(id: ID!, collapseDate: DateTime!, collapseCause: String!): Hive

  """
  Split a hive by moving selected frames to a new hive.

  queenAction options:
  - "new_queen": Install a new queen in the split hive (requires queenName)
  - "take_old_queen": Move the old queen from source to split hive (source becomes queenless)
  - "no_queen": Create a queenless split (for raising their own queen from cells)

  queenName is required only when queenAction is "new_queen"
  """
  splitHive(sourceHiveId: ID!, queenName: String, queenAction: String!, frameIds: [ID!]!): Hive

  joinHives(sourceHiveId: ID!, targetHiveId: ID!, mergeType: String!): Hive

  updateHivePlacement(apiaryId: ID!, hiveId: ID!, x: Float!, y: Float!, rotation: Float!): HivePlacement
  addApiaryObstacle(apiaryId: ID!, obstacle: ApiaryObstacleInput!): ApiaryObstacle
  updateApiaryObstacle(id: ID!, obstacle: ApiaryObstacleInput!): ApiaryObstacle
  deleteApiaryObstacle(id: ID!): Boolean
}

input TreatmentOfBoxInput {
  hiveId: ID!
  boxId: ID!
  type: String!
}

input TreatmentOfHiveInput {
  hiveId: ID!
  type: String!
}

input ApiaryInput {
  name: String!
  lat: String
  lng: String
}

type Apiary {
  id: ID!
  name: String
  hives: [Hive]
  location: String
  lat: String
  lng: String
}

input HiveInput {
  apiaryId: ID!
  queenName: String
  queenYear: String
  queenColor: String
  hiveNumber: Int
  boxCount: Int!
  frameCount: Int!
  colors: [String]
}

input HiveUpdateInput {
  id: ID!
  hiveNumber: Int
	notes: String
  family: FamilyInput
}

""" Hive name is now stored in Family.name """
type Hive @key(fields: "id") {
  id: ID!
  hiveNumber: Int
  notes: String
  boxes: [Box]
  family: Family
  families: [Family]

  boxCount: Int!
  inspectionCount: Int!

  status: String
  added: DateTime!

  """ true if added < 1 day """
  isNew: Boolean!
  lastInspection: DateTime
  collapse_date: DateTime
  collapse_cause: String
  parentHive: Hive
  splitDate: DateTime
  childHives: [Hive]
  mergedIntoHive: Hive
  mergeDate: DateTime
  mergeType: String
  mergedFromHives: [Hive]
}

input FamilyInput{
  id: ID
  name: String
  race: String
  added: String
  color: String
}

input BoxInput{
  id: ID
  position: Int!
  color: String
  type: BoxType!
  "ignored, added for frontend ease"
  hiveId: Int
  family: FamilyInput
}

type Treatment {
  id: ID!
  type: String!
  added: DateTime!
  
  hiveId: ID!
  boxId: ID!
  familyId: ID!
}

type Family{
  id: ID!

  """ name of the queen """
  name: String

  """ freeform race of the queen """
  race: String

  """ year when queen was added """
  added: String

  """ custom color for queen marking, overrides year-based color if set """
  color: String

  """ queen age in years, depends on added date"""
  age: Int

  """ aggregate info about Treatments """
  lastTreatment: DateTime

  """Anti-varroa medical treatments of a hive or a box are linked to a family to track history even if family is moved to another hive or ownership is changed"""
  treatments: [Treatment]
}

type Inspection {
  id: ID!
  hiveId: ID!
  data: JSON!
  added: DateTime!
}

input InspectionInput{
  hiveId: Int!
  data: JSON!
}

type Box{
  id: ID
  position: Int
  color: String
  type: BoxType!
  frames: [Frame]
}

input FrameInput{
  id: ID!
  position: Int!
  type: FrameType!
  "ignored, added for frontend ease"
  boxId: ID!
  "ignored, added for frontend ease"
  hiveId: Int
}

type Frame{
  id: ID
  position: Int!
  type: FrameType!
  leftSide: FrameSide,
  rightSide: FrameSide
}

enum BoxType {
  DEEP
  SUPER
  GATE
  VENTILATION
  QUEEN_EXCLUDER
  HORIZONTAL_FEEDER
  BOTTOM
}

enum FrameType {
  VOID
  FOUNDATION
  EMPTY_COMB
  PARTITION
  FEEDER
}

type FrameSide @key(fields: "id") {
  id: ID
  frameId: ID
}

type HivePlacement {
  id: ID!
  apiaryId: ID!
  hiveId: ID!
  x: Float!
  y: Float!
  rotation: Float!
}

type ApiaryObstacle {
  id: ID!
  apiaryId: ID!
  type: ObstacleType!
  x: Float!
  y: Float!
  width: Float
  height: Float
  radius: Float
  rotation: Float!
  label: String
}

enum ObstacleType {
  CIRCLE
  RECTANGLE
}

input ApiaryObstacleInput {
  type: ObstacleType!
  x: Float!
  y: Float!
  width: Float
  height: Float
  radius: Float
  rotation: Float
  label: String
}

